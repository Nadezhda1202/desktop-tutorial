# Дополнительно

## Логические конструкции

### if, elseif, else

В PowerShell условные операторы позволяют программе принимать решения и выполнять разные блоки кода в зависимости от условий.

* Конструкция `if() {}` проверяет условие в круглых скобках и выполняет блок кода, если условие истинно.
* Ключевые слова `elseif{}` и `else{}` используются для добавления дополнительных проверок и альтернативных действий.
* При этом блоки `elseif` и `else` не обязательны: можно использовать только `if`.

Пример:

```powershell
if ($number -gt 10) {
    Write-Output "Число больше 10"
} elseif ($number -eq 10) {
    Write-Output "Число равно 10"
} else {
    Write-Output "Число меньше 10"
}
```

Если условие в `if` истинно, последующие `elseif` и `else` пропускаются.

Можно использовать несколько `elseif` подряд для проверки нескольких вариантов.

Блок `else` выполняется, когда все предыдущие условия ложны.

Дополнительную информацию можно посмотреть по ссылке:

{% embed url="https://docs.microsoft.com/ru-ru/powershell/scripting/learn/deep-dives/everything-about-if?view=powershell-7.1" %}

### switch

switch — это удобная конструкция для проверки переменной на множество значений и выбора соответствующего блока кода.

```powershell
switch ($variable) {
    0 { Write-Output "Значение равно 0" }
    1 { Write-Output "Значение равно 1" }
    2 { Write-Output "Значение равно 2" }
    default { Write-Output "Значение не соответствует ни одному из условий" }
}
```

* Для каждого значения перечисляется блок кода, который будет выполнен, если значение переменной совпадает.
* Блок `default` необязателен и выполняется, если ни одно из значений не подошло.
* `switch` удобен для множественных вариантов выбора, сокращая многократные вложенные конструкции if.

Дополнительную информацию можно посмотреть по ссылке:

{% embed url="https://docs.microsoft.com/ru-ru/powershell/scripting/learn/deep-dives/everything-about-switch?view=powershell-7.1" %}

## Проверка на $null

В PowerShell для проверки равенства с $null рекомендуется всегда ставить $null слева в выражении:

```powershell
$null -eq $value
```

Это связано с особенностями обработки значений в PowerShell, чтобы избежать неожиданных ошибок, если $value не определено.

В логических выражениях PowerShell можно использовать командлеты и функции, которые будут оцениваться как булевы значения по своей логике истинности/ложности. Например, условие:

```powershell
if ($null_object) {
    $False
} else {
    $True
}
```

Будет считать `$null_object` как ложное условие (если пустой или $null) и выполнять соответствующий блок.

Также возможно назначать значения переменным прямо внутри условия, что удобно для одновременного присваивания и проверки на $null. Например:

```powershell
if ($var = (function)) {
    $True
} else {
    $False
}
```

Здесь переменной `$var` присваивается результат функции, и сразу проверяется, не является ли он $null (или пустым).

Аналогично проверка переменной на саму себя:

```powershell
if ($var = $var) {
    $True
} else {
    $False
}
```

Дополнительную информацию можно посмотреть по ссылке:

{% embed url="https://docs.microsoft.com/ru-ru/powershell/scripting/learn/deep-dives/everything-about-null?view=powershell-7.1" %}

## Строки подстановки

В PowerShell существует несколько способов формирования и объединения строк.

### Кавычки

Переменные можно вставлять прямо в строки с разным типом кавычек:

```powershell
$string = "’объект’"
$string1 = "продан"

"Тестовый’ $string успешно”” $string1”   # Результат: Тестовый’ ‘объект’ успешно” продан

'Тестовый” '+$string+' успешно’’ '+$string1  # Результат: Тестовый” ‘объект’ успешно’ продан
```

### HereString

Можно применять HereString для объявления многострочной строки с сохранением форматирования:

```powershell
@"
Тестовый+@’ $string успешно” $string1
"@
```

Результат будет строго соответствовать тому, что содержится внутри.

### F-строки

Также существуют F-строки для форматирования строк с параметрами:

```powershell
("Тестовый {0} успешно {1}" -f $string, $string1)
```

## PSCustomObject

PSCustomObject — это объект PowerShell, который хранит данные по принципу хэш-таблицы, но с ним можно работать как с объектом, обращаясь к полям через точку.

Это позволяет удобно структурировать данные, создавать объекты с нужными свойствами и выполнять операции.

Дополнительную информацию о PSCustomObject можно посмотреть по ссылке:

{% embed url="https://docs.microsoft.com/ru-ru/powershell/scripting/learn/deep-dives/everything-about-pscustomobject?view=powershell-7.1" %}

## Учетные данные

В PowerShell существуют специальные механизмы для безопасной работы с учетными данными, включая встроенные функции и параметры, а также конструкции, которые обеспечивают информирование пользователя об изменениях и позволяют управлять процессом выполнения (например, ShouldProcess).

Дополнительную информацию о ShouldProcess можно посмотреть по ссылке:

{% embed url="https://docs.microsoft.com/ru-ru/powershell/scripting/learn/deep-dives/everything-about-shouldprocess?view=powershell-7.1" %}

## Ошибка запуска файлов ps1

Ошибка запуска файлов .ps1 в PowerShell связана с политикой выполнения скриптов, которая по умолчанию запрещает запуск любых скриптов для защиты системы от вредоносного кода.&#x20;

Сообщение об ошибке выглядит так:

```powershell
«Невозможно загрузить файл ... .ps1, так как выполнение сценариев отключено в этой системе».
```

Причина в том, что Windows использует Execution Policy — набор правил, определяющих, какие скрипты можно запускать. По умолчанию стоит политика `Restricted`, которая блокирует скрипты.

Проверить текущую политику можно командой:

```powershell
Get-ExecutionPolicy
```

Чтобы разрешить запуск скриптов:

1. Запустите PowerShell или PowerShell ISE от имени администратора.
2. Выполните команду:

```powershell
Set-ExecutionPolicy Unrestricted
```

3. Подтвердите изменение, нажав "Да" (Yes).

Это позволит запускать скрипты с расширением .ps1 без ограничений.

Для более строгого контроля можно выбрать другие уровни политики, такие как `RemoteSigned` или `AllSigned`.
